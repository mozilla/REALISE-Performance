# -*- coding: utf-8 -*-
"""process_alerts_post_SP_update.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1QUpBgc8R649dUN52kskpiT2FA8_q2cpY
"""

import pandas as pd
from datetime import datetime, timedelta
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', None)
df_new = pd.read_csv('/content/1_rectified_alerts_data.csv')
df = pd.read_csv('/content/alerts_data.csv')

alerts_timedate_cols = ['alert_creation_timestamp', 'alert_first_triaged', 'alert_triage_due_date', 'alert_bug_due_date', 'alert_bug_updated']
for i in alerts_timedate_cols:
  df[i] = pd.to_datetime(df[i], format='%Y-%m-%dT%H:%M:%S.%f')
df['alert_push_timestamp'] = pd.to_datetime(df['alert_push_timestamp'], unit='s')

for i in alerts_timedate_cols:
  df_new[i] = pd.to_datetime(df_new[i], format='%Y-%m-%dT%H:%M:%S.%f')
df_new['alert_push_timestamp'] = pd.to_datetime(df_new['alert_push_timestamp'], unit='s')

def compare_common_test_id_rows(df, df_new):
    # Ensure the 'test_id' column exists in both dataframes
    if 'test_id' not in df.columns or 'test_id' not in df_new.columns:
        raise ValueError("The 'test_id' column is missing in one or both dataframes.")

    # Find the common test_id values
    common_test_ids = set(df['test_id']).intersection(set(df_new['test_id']))
    exclusive_df_test_ids = set(df['test_id']) - common_test_ids
    exclusive_df_new_test_ids = set(df_new['test_id']) - common_test_ids

    # Filter rows with common test_ids
    rows_with_common_test_ids_df = df[df['test_id'].isin(common_test_ids)].copy()
    rows_with_common_test_ids_df_new = df_new[df_new['test_id'].isin(common_test_ids)].copy()

    # Filter rows with mutually exclusive test_ids
    exclusive_rows_df = df[df['test_id'].isin(exclusive_df_test_ids)].copy()
    exclusive_rows_df_new = df_new[df_new['test_id'].isin(exclusive_df_new_test_ids)].copy()

    # Sort columns alphabetically and rows by 'alert_push_timestamp' if it exists
    rows_with_common_test_ids_df = rows_with_common_test_ids_df[sorted(rows_with_common_test_ids_df.columns)]
    rows_with_common_test_ids_df_new = rows_with_common_test_ids_df_new[sorted(rows_with_common_test_ids_df_new.columns)]
    exclusive_rows_df = exclusive_rows_df[sorted(exclusive_rows_df.columns)]
    exclusive_rows_df_new = exclusive_rows_df_new[sorted(exclusive_rows_df_new.columns)]

    if 'alert_push_timestamp' in rows_with_common_test_ids_df.columns and 'alert_push_timestamp' in rows_with_common_test_ids_df_new.columns:
        rows_with_common_test_ids_df = rows_with_common_test_ids_df.sort_values(by='alert_push_timestamp').reset_index(drop=True)
        rows_with_common_test_ids_df_new = rows_with_common_test_ids_df_new.sort_values(by='alert_push_timestamp').reset_index(drop=True)

    if 'alert_push_timestamp' in exclusive_rows_df.columns and 'alert_push_timestamp' in exclusive_rows_df_new.columns:
        exclusive_rows_df = exclusive_rows_df.sort_values(by='alert_push_timestamp').reset_index(drop=True)
        exclusive_rows_df_new = exclusive_rows_df_new.sort_values(by='alert_push_timestamp').reset_index(drop=True)

    # Find common rows
    common_rows = pd.merge(rows_with_common_test_ids_df, rows_with_common_test_ids_df_new, how='inner')

    # Find differences between common test_id rows
    row_diff = pd.concat([rows_with_common_test_ids_df, rows_with_common_test_ids_df_new]).drop_duplicates(keep=False)

    return (
        rows_with_common_test_ids_df,
        rows_with_common_test_ids_df_new,
        common_rows,
        row_diff,
        exclusive_rows_df,
        exclusive_rows_df_new
    )
(rows_with_common_test_ids_df,
 rows_with_common_test_ids_df_new,
 common_rows,
 row_diff,
 exclusive_rows_df,
 exclusive_rows_df_new) = compare_common_test_id_rows(df, df_new)

def compare_test_id_values(df, df_new):
    # Ensure the 'test_id' column exists in both dataframes
    if 'test_id' not in df.columns or 'test_id' not in df_new.columns:
        raise ValueError("The 'test_id' column is missing in one or both dataframes.")

    # Extract unique test_id values from both dataframes
    test_id_df = set(df['test_id'])
    test_id_df_new = set(df_new['test_id'])

    # Find values in df but not in df_new, and vice versa
    only_in_df = test_id_df - test_id_df_new
    only_in_df_new = test_id_df_new - test_id_df

    return only_in_df, only_in_df_new

# Example usage
only_in_df, only_in_df_new = compare_test_id_values(df, df_new)

# Output results
# print("Values in 'test_id' that are only in df:")
# print(len(only_in_df))
# print(only_in_df)

# print("\nValues in 'test_id' that are only in df_new:")
# print(len(only_in_df_new))
# print(only_in_df_new)

alert_creation_timestamp_threshold = df_new[df_new['alert_status'].isin([0, 5])]['alert_creation_timestamp'].min()
lost_alerts = df[(df['test_id'].isin(only_in_df)) & (df['alert_status'].isin([0, 5])) & (df['alert_creation_timestamp'] < alert_creation_timestamp_threshold)]

result = pd.concat([df_new, lost_alerts], ignore_index=True)

result.sort_values(by="alert_push_timestamp", ascending=True)

(rows_with_common_test_ids_df_2,
 rows_with_common_test_ids_df_new_2,
 common_rows_2,
 row_diff_2,
 exclusive_rows_df_2,
 exclusive_rows_df_new_2) = compare_common_test_id_rows(df, result)

result.to_csv('/content/2_recitified_alerts_data.csv', index=False)

grp = df.groupby("alert_id")["alert_status"].nunique()
revisions_with_more_than_one_timestamp = grp[grp > 1].index.tolist()
print(len(revisions_with_more_than_one_timestamp))